# this is the text which will end up within readme.pdf, when processed
# by readme.php.
#
# the syntax being used is fairly obvious:
#
# a line starting with '#' is a comment or a directive
# 1<title>  is a first level heading (text is 'title')
# 2<heading> is a second level heading (text is 'heading')
#
# the table of contents is automatically generated from the titles and headings.
#
# "#NP" starts a new page
# "#C" starts a code section (put this on a line by itself
# "#c" end the code section
# "#X" and "#x" surround a block which will be executed as php code.
#
# <b></b> <i></i> can be used within the text with gleeful abandon
#
# a link can be added within the text using <c:alink:url_here>label</c:alink>


1<Introduction>

This class is designed to provide a <b>non-module</b>, non-commercial alternative to dynamically creating pdf documents from within PHP.
Obviously this will not be quite as quick as the module alternatives, but it is surprisingly fast, this demonstration page is almost a worst case due to the large number of fonts which are displayed.
There are a number of features which can be within a Pdf document that it is not at the moment possible to use with this class, but I feel that it is useful enough to be released.

This document describes the possible useful calls to the class, the readme.php file (which will create this pdf) should be sufficient as an introduction.

Note that this document was generated using the demo script 'readme.php' which came with this package.

1<Changes>


2<version 009>

- support for underlining in the ezPdf class (but only in the base class functions using the callback function directly).
- improvements to the underlining of the links, so that it is sized and positioned better, will work with angled text now.
- automatic column support.
- some improvements to the table functions. Can set row and column gaps. The table will not now split rows across pages by default.
- addition of transaction control support to the base class (this is quite useful, recommend advanced users take special note).
- numerous small bug fixes, including notably some bugs relating to the inclusion of fonts, especially when using the differences array to take care of characters normally outside the default set.


2<version 008>

changes to class.pdf.php:

- adjustment to the way that type 1 fonts are loaded to make them more reliable
- changes to that angled text can use bold and italic tags
- implemented file encryption, which gives the ability to restrict user cut and paste, or printing.
- added callback functions activated by text markers, see the misc section for full decription.
- allow object to be added on the 'next' page.
- extended the newPage function to allow insertion of extra pages between existing pages.
- adjustment to ellipse function to allow partial curves.

changes to class.ezpdf.php:

- made the column headings in the tables have the same alignment as the settings for the column data.
- adjusted the size of an A4 page to be more accurate.
- fixed the table title alignment to stay centered on the table if the table position is fixed on the page
- used callback functions to add clickable links to the text.
- implemented a better algorithm for determining table widths when it needs to be shrunk to width.
- changed ezTable and ezText to return the y-position.
- made the page numbering system more functional.
- added insert page functionality.
- added link capability to tables, can specify one column to be links, using another column as URLs.


2<version 007>

This is it - the james bond version - though all similarity ends with the name, but there are some funky new features and a few bug fixes.

The ezTable features have been extended, it is now possible to define the justification of the individual columns, and to specify colum widths as well as the width of the entire table.

You can now have <b>extra fonts!</b>. It is possible to add type 1 postscript fonts, or TrueType fonts. Though note that for the postscript font you have to have both a .pfb file and a .afm file - but there are free products out there which can convert a .pfa to a .pfb. Also to use a TrueType file you have to have a corersponding .afm file as this is required to specify the character widths - luckily there is a program which will generate one from a ttf file.

Bugfixes:
- fix the open font command so that the font file can be in the same directory.
- fix a bug with full justification, a space was being left at the end of each line - the justification now lines up much better.
- added some binary characters near the start of the pdf file, this is so that transfer programs will recognise it as binary.
- adjusted addTextWrap so that a text angle can now be supplied.
- have found that the reasona that jpeg file loading was not working for a lot of people is that if magic_quotes_runtime is set on in the php.ini file, then the file read is not binary safe. Adjusted the code to turn that option off before the read, then on again afterwards - there is at least one report of it working much better now.
- added the missing code to specify the xPos of a table - this was documented in the last version, but someone forgot to code it.


2<version 006>

Still more bug fixes of course, but also some improved functionality.

It is now possible to use &lt;b>&lt;/b>&lt;i>&lt;/i> markers within the text stream to do the obvious functionality. This depends on 'font families' being set up, which are described later.

The table functionality within ezPdf has been enhanced so that the width of a table can be specified and the cell contents will be wrapped to fit.

There is some trial functionality to allow the specification of adjusted character maps, this does mean that this version will have to re-create your 'php_<font>.afm' files, but it will do it automatically on first use, <b>but make sure you have the adobe .afm files in the directory and that the web-server has write access</b>, alternatively download the new ones.

Also there has been a slight attempt to tidy the code a little, and improve the documentation. This is partly in preparation for this project to be put into SourceForge, as it will be immediatly following this release.

2<version 005>

Contains a few bug fixes from 004, and the addition of the capability to draw arbitrary Bezier curves, and ellipses at arbitrary angles.

2<version 004>

This release includes a certain amount of functionality which should have been in 003. The enhancements are:
- page numbering easily done within ezpdf, they can be started and stopped on any page, uses an arbitrary template for the format, and can be set to start numbering pages from a given number.
- can now pass content-disposition through to the headers, for what it is worth
- having the 'Accept-Ranges' header set is optional, and off by default - seemed to cause problems.
- lines can now have their width, dash patterns, join types and endings set.
- there is now a reopenObject function which will allow adding content to previous objects, as long as the id has been stored. This function will also now work on pages, and the newpage() function now returns an id so that these can be accessed. 
- the first page of course does not return an id, so there is a getFirstPageId() function to find that one.

2<notes from version 003>

This is the document accompanying version 003 of this pdf class, the significant changes in this class version are:
- Creation of the ezpdf class, an extension to the base class to make life simpler.
Inclusion of compression within the content streams, code from Andrea Gagliardi (thanks).
- A new image function which will include a jpeg file straight from the file, so image inclusion without using GD.
- An extra content header, might improve life on some browsers (thanks John Arthur).


1<Use>

It is free for use for any purpose (public domain), though we would prefer it if you retain the notes at the top of the class containing the authorship, and feedback details.

Note that there is no guarantee or warranty, implied or otherwise with this class, or the extension.

1<Extensions>

In order to create simple documents with ease a class extension called 'ezPdf' has been developed, at the moment this includes auto page numbering, tabular data presentation, text wrapping to new pages, etc. This document has been created using mostly ezPdf functions.

The functions of ezpdf are described in the next section, though as it is a class extension, all of the basic functions from the original class are still available.

Please excuse this blatant 'plug', but if your company wishes some customization of these routines for your purposes, R&OS can do this at very reasonable rates, just drop us a line at info@ros.co.nz.

#NP
1<EZPDF Class Extension>


(note that the creation of this document in readme.php was converted to ezpdf with the saving of many lines of code).

It is anticipated that in practise only the simplest of documents will be able to be created using just ezpdf functions, they should be used in conjunction with the base class functions to achieve the desired result.


2<Cezpdf>

Cezpdf([paper='a4'],[orientation='portrait'])

This is the constructor function, and allows the user to set up a basic page without having to know exactly how many units across and up the page is going to be.
Valid values for paper are listed below, a two or four member array can also be passed, a two member array will be interpreted as the size of the page in centimeters, and a four member array will be the size of the page in points, similar to the call to the base calss constructor function.
Valid values for orientation are 'portrait','landscape'.
Starting ezpdf with the code below will create an a4 portrait document.

#C
$pdf =& new Cezpdf();
#c

If you want to get started in an easy manner, then here is the 'hello world' program:

#C
<?php
include ('class.ezpdf.php');
$pdf =& new Cezpdf();
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezText('Hello World!',50);
$pdf->ezStream();
?>
#c

Note that some people have reported that this gives an error - it appears that some builds of PHP do not support the =& operator, if you are having problems then try changing the class instantiation line to:
#C
$pdf = new Cezpdf();
#c

The valid values for the paper (thanks to the work of Nicola Asuni) are:

'4A0' (4767.87,6740.79), '2A0' (3370.39,4767.87), 'A0' (2383.94,3370.39), 'A1' (1683.78,2383.94), 'A2' (1190.55,1683.78), 'A3' (841.89,1190.55), 'A4' (595.28,841.89), 'A5' (419.53,595.28), 'A6' (297.64,419.53), 'A7' (209.76,297.64), 'A8' (147.40,209.76), 'A9' (104.88,147.40), 'A10' (73.70,104.88), 'B0' (2834.65,4008.19), 'B1' (2004.09,2834.65), 'B2' (1417.32,2004.09), 'B3' (1000.63,1417.32), 'B4' (708.66,1000.63), 'B5' (498.90,708.66), 'B6' (354.33,498.90), 'B7' (249.45,354.33), 'B8' (175.75,249.45), 'B9' (124.72,175.75), 'B10' (87.87,124.72), 'C0' (2599.37,3676.54), 'C1' (1836.85,2599.37), 'C2' (1298.27,1836.85), 'C3' (918.43,1298.27), 'C4' (649.13,918.43), 'C5' (459.21,649.13), 'C6' (323.15,459.21), 'C7' (229.61,323.15), 'C8' (161.57,229.61), 'C9' (113.39,161.57), 'C10' (79.37,113.39), 'RA0' (2437.80,3458.27), 'RA1' (1729.13,2437.80), 'RA2' (1218.90,1729.13), 'RA3' (864.57,1218.90), 'RA4' (609.45,864.57), 'SRA0' (2551.18,3628.35), 'SRA1' (1814.17,2551.18), 'SRA2' (1275.59,1814.17), 'SRA3' (907.09,1275.59), 'SRA4' (637.80,907.09), 'LETTER' (612.00,792.00), 'LEGAL' (612.00,1008.00), 'EXECUTIVE' (521.86,756.00), 'FOLIO' (612.00,936.00)


2<ezSetMargins>

ezSetMargins(top,bottom,left,right)

Sets the margins for the document, this command is optional and they will all be set to 30 by default. Setting these margins does not stop you writing outside them using the base class functions, but the ezpdf functions will wrap onto a new page when they hit the bottom margin, and will not write over the side margins when using the <b>ezText</b> command below.

2<ezSetCmMargins>

ezSetCmMargins(top,bottom,left,right)

Sets the margins for the document using centimeters

2<ezNewPage>

ezNewPage()

Starts a new page. This is subtly different to the newPage command in the base class as it also places the ezpdf writing pointer back to the top of the page. So if you are using the ezpdf text functions, then this is the one to use when manually requesting a new page.

2<ezInsertMode>

ezInsertMode([status=1,$pageNum=1,$pos='before'])

This command can be used to stop and start page insert mode, while this mode is on then any new page will be inserted into the midst of the document. If it is called with status=1, then insert mode is started and subsequent pages are added before or after page number 'pageNum'. 'pos' can be set to 'before' or 'after' to define where the pages are put. The 'pageNum' is set to which page number this position is relative to.

All subsequent pages added with ezNewPage are then inserted within the document following the last inserted page.

Insertion page is ended by calling this command with 'status'=0, and further pages are added to the end of the document.

2<ezSetY>

ezSetY(y)

Positions the ezpdf writing pointer to a particular height on the page, don't forget that pdf documents have <b>y-coordinates which are zero at the bottom of the page and increase as they go up</b> the page.

2<ezSetDy>

ezSetDy(dy [,mod])

Changes the vertical position of the writing point by a set amount, so to move the pointer 10 units down the page (making a gap in the writing), use:

#C
ezSetDy(-10)
#c

If this movement makes the writing location below the bottom margin, then a new page will automatically be made, and the pointer moved to the top of it.

The optional parameter 'mod' can be set to the value 'makeSpace', which means that if a new page is forced, then the pointer will be moved the distance 'dy' on the new page as well. The intention of this is if you needed 100 units of space to draw a picture, then doing:

#C
ezSetDy(-100,'makeSpace')
#c

guarantees that there will be 100 units of space above the final writing point.

2<ezTable>

y=ezTable(array data,[array cols],[title],[array options]

The easy way to throw a table of information onto the page, can be used with just the data variable, which must contain a two dimensional array of data. This function was made with data extracted from database queries in mind, so is expecting it in that format, a two dimensional array with the first array having one entry for each row (and each of those is another array).

The table will start writing from the current writing point, and will proceed until the all the data has been presented, by default, borders will be drawn, alternate limes will be shaded gray, and the table will wrap over pages, re-printing the headers at the top of each page.

The return value from the function is the y-position of the writing pointer after the table has been added to the document.

The other options are described here:

$cols (optional) is an associative array, the keys are the names of the columns from $data to be presented (and in that order), the values are the titles to be given to the columns, if this is not wanted, but you do want later options then '' (the empty string) is a suitable placeholder.

$title (optional) is the title to be put on the top of the table

$options is an associative array which can contain:
 'showLines'=> 0,1,2, default is 1 (1->show the borders, 0->no borders, 2-> show borders AND lines between rows.)
 'showHeadings' => 0 or 1
 'shaded'=> 0,1,2, default is 1 (1->alternate lines are shaded, 0->no shading, 2->both sets are shaded)
 'shadeCol' => (r,g,b) array, defining the colour of the shading, default is (0.8,0.8,0.8)
 'shadeCol2' => (r,g,b) array, defining the colour of the shading of the second set, default is (0.7,0.7,0.7), used when 'shaded' is set to 2.
 'fontSize' => 10
 'textCol' => (r,g,b) array, text colour
 'titleFontSize' => 12
 'rowGap' => 2 , the space between the text and the row lines on each row
 'colGap' => 5 , the space between the text and the column lines in each column
 'lineCol' => (r,g,b) array, defining the colour of the lines, default, black.
 'xPos' => 'left','right','center','centre',or coordinate, reference coordinate in the x-direction
 'xOrientation' => 'left','right','center','centre', position of the table w.r.t 'xPos'. This entry is to be used in conjunction with 'xPos' to give control over the lateral position of the table.
 'width' => <number>, the exact width of the table, the cell widths will be adjusted to give the table this width.
 'maxWidth' => <number>, the maximum width of the table, the cell widths will only be adjusted if the table width is going to be greater than this.
 'cols' => array(<colname>=>array('justification'=>'left','width'=>100,'link'=><linkColName>),<colname>=>....) ,allow the setting of other paramaters for the individual columns, each column can have its width and/or its justification set.
 'innerLineThickness' => <number>, the thickness of the inner lines, defaults to 1
 'outerLineThickness' => <number>, the thickness of the outer lines, defaults to 1
 'protectRows' => <number>, the number of rows to keep with the heading, if there are less than this on a page, then all is moved to the next page.
 
Note that the user will have had to have made a font selection already or this will not produce a valid pdf file.

Note that in version 009, with the introduction of colGap and rowGap, the defaults for these have changed slightly, so default tables may appear slightly different, it will pay to check your documents if this is likely to cause a formatting problem for you. Problems could also be caused by the new default behaviour to not allow rows to be split across page boundaries. Another possible problem is that 'titleGap' was removed, as it was felt that this functionality was replaced by rowGap and colGap.

A simple table example:

#C
<?php
include ('class.ezpdf.php');
$pdf =& new Cezpdf();
$pdf->selectFont('./fonts/Helvetica.afm');

$data = array(
 array('num'=>1,'name'=>'gandalf','type'=>'wizard')
,array('num'=>2,'name'=>'bilbo','type'=>'hobbit','url'=>'http://www.ros.co.nz/pdf/')
,array('num'=>3,'name'=>'frodo','type'=>'hobbit')
,array('num'=>4,'name'=>'saruman','type'=>'bad dude','url'=>'http://sourceforge.net/projects/pdf-php')
,array('num'=>5,'name'=>'sauron','type'=>'really bad dude')
);

$pdf->ezTable($data);

$pdf->ezStream();
?>
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');

$data = array(
 array('num'=>1,'name'=>'gandalf','type'=>'wizard')
,array('num'=>2,'name'=>'bilbo','type'=>'hobbit','url'=>'http://www.ros.co.nz/pdf/')
,array('num'=>3,'name'=>'frodo','type'=>'hobbit')
,array('num'=>4,'name'=>'saruman','type'=>'bad dude','url'=>'http://sourceforge.net/projects/pdf-php')
,array('num'=>5,'name'=>'sauron','type'=>'really bad dude')
);

$pdf->ezTable($data);
#x

For a slightly more complex example, print that table again, but only the second and third columns, and in the other order, also have column headings and a table heading.

#C
$pdf->ezTable($data,array('type'=>'Type','name'=>'&lt;i>Alias&lt;/i>')
          ,'Some LOTR Characters');
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezTable($data,array('type'=>'Type','name'=>'<i>Alias</i>')
              ,'Some LOTR Characters');
#x

and the same, but with no headings or shading, or lines:

#C
$pdf->ezTable($data,array('type'=>'Type','name'=>'&lt;i>Alias&lt;/i>')
              ,'Some LOTR Characters'
              ,array('showHeadings'=>0,'shaded'=>0,'showLines'=>0));
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezTable($data,array('type'=>'Type','name'=>'<i>Alias</i>')
              ,''
              ,array('showHeadings'=>0,'shaded'=>0,'showLines'=>0));
#x

Now a version with the width specified to be too small, so that the content has to wrap, and the table oriented over the the right.

#C
$pdf->ezTable($data,array('type'=>'','name'=>''),''
          ,array('showHeadings'=>0,'shaded'=>0,'xPos'=>'right'
                ,'xOrientation'=>'left','width'=>100));
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezTable($data,array('type'=>'','name'=>'')
              ,''
              ,array('showHeadings'=>0,'shaded'=>0,'xPos'=>'right','xOrientation'=>'left','width'=>100));
#x

Now the column headings have been changed, one to a long name which wraps, and also have a return code in it. The 'num' column has been right justified, and the 'name' column fixed to a width of 100. The entire table is fixed to a width of 300. The x position of the table is also fixed to 90, and the table is set to be on the right of this point.

#C
$cols = array('num'=>"number a a a a a a a a a a a a a a a\nmore"
             ,'name'=>'Name','type'=>'Type');

$pdf->ezTable($data,$cols,'',
        array('xPos'=>90,'xOrientation'=>'right','width'=>300
             ,'cols'=>array(
                 'num'=>array('justification'=>'right')
                ,'name'=>array('width'=>100))
             ));
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');
$cols = array('num'=>"number a a a a a a a a a a a a a a a\nmore",'name'=>'Name','type'=>'Type');

$pdf->ezTable($data,$cols,'',array('xPos'=>90,'xOrientation'=>'right','width'=>300
         ,'cols'=>array('num'=>array('justification'=>'right'),'name'=>array('width'=>100))
         ));
#x

A simple example, showing the table expanding to fit the specified width, and having links on one of the table columns.

#C
$pdf->ezTable($data,array('type'=>'','name'=>''),''
              ,array('showHeadings'=>0
                    ,'shaded'=>0
                    ,'width'=>400
                    ,'cols'=>array('name'=>array('link'=>'url')) ));
#c

#X
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezTable($data,array('type'=>'','name'=>'')
              ,''
              ,array('showHeadings'=>0,'shaded'=>0,'width'=>400
              ,'cols'=>array('name'=>array('link'=>'url'))
              ));
#x


2<ezText>

y=ezText(text,[size],[array options])

This is designed for putting blocks of text onto the page. It will add a string of text to the document (note that the string can be very large, spanning multiple pages), starting at the current drawing position. It will wrap to keep within the margins, including optional offsets from the left and the right, if $size is not specified, then it will be the last one used, or the default value (12 I think). The text will go to the start of the next line when a return code "\n" is found.

The return value from the function (y) is the vertical position on the page of the writing pointer, after the text has been added.

possible options are:
 'left'=> number, gap to leave from the left margin
 'right'=> number, gap to leave from the right margin
 'aleft'=> number, absolute left position (overrides 'left')
 'aright'=> number, absolute right position (overrides 'right')
 'justification' => 'left','right','center','centre','full'

 only set one of the next two items (leading overrides spacing)
 'leading' => number, defines the total height taken by the line, independent of the font height.
 'spacing' => a real number, though usually set to one of 1, 1.5, 2 (line spacing as used in word processing)

This function now supports the use of underlining markers (&lt;u> &lt;/u>), these are implemented via a callback function, which is information that you need only of you want to use them in functions in the base class, as these markers will not work there and the full callback function markers wil have to be used (though note that ezPdf stillhas to be part of the class object as the callback function are included with that code base. The callback function markers would look like &lt;c:uline>this&lt;/c:uline>.


2<ezImage>

ezImage(image,[padding],[width],[resize],[justification],[array border])

This function makes it much easier to simply place an image (either jpeg or png) within the flow of text within a document.  Although this function can certainly be used with full page documents, its functionality is most suited to documents that are formatted in multiple columns.

This function can be used by simply supplying the name of an image file as the first argument.  The image will be resized to fit centered within the current column with the default padding of 5 on each side.

The arguments are:

$image is a string containing the filename and path of the jpeg or png image you want to insert into the page.  If allow_url_fopen is enabled in the PHP ini settings this can be an HTTP or FTP URL.

$padding (optional) is the number of page units that will pad the image on all sides.  The default is five (5).  If you do not want any padding, you may enter 0.

$width (optional) is the width of the image on the page.  The default is to use the actual width of the image in pixels.  Whether or not you specify a width, the actual width of the image on the page will depend on what you enter for the $resize argument as well as the placement of the image on the page.

$resize (optional) can be one of 'full', 'width', or 'none'.  The default value is 'full'.  

The value 'none' means that an image will not be sized up to fit the width of a column and will not be sized down vertically to fit within the current page. If the image is too long to fit on the page it will be placed on the next page or column.  If the image is too wide to fit within the current column, it will still be sized down.  This is because there is no alternative, other than to actually let the image run off the page.

The value 'width' behaves the same as 'none' with the exception that images will be resized to fit the width of the current column if the given width is smaller that the current column (minus the padding).

The value 'full' behaves the same as 'width' with the exception that images will be resized down vertically to fit within the current page and column if their height is too long to fit.

$justification (optional) determines the horizontal position of the image within the current column.  The default is 'center', and can be specified as either 'center', 'left', or 'right'.  This setting has little meaning if the image has been resized to fit the column and only makes a practical difference if the width of the image is smaller than the width of the column.

$border (optional) is an array which specifies the details of the border around the image.  The default is no border if this argument is not given.  You may specify any of the following border elements:

$border['width'] is the width of the border.  The default is 1.
$border['cap'] is the cap type as specified in setLineStyle.  The default is 'round'.
$border['join'] is the join type as specified in setLineStyle.  The default is 'round'.
$border['color'] is an associative array for specifying the line color of the border.
The values are as specified in setStrokeColor and should be assigned to:
$border['color']['red'], $border['color']['green'] and $border['color']['blue'] respectively.


2<ezStartPageNumbers>

setNum = ezStartPageNumbers(x,y,size,[pos],[pattern],[num])

 Add page numbers on the pages from here, place then on the 'pos' side of the coordinates (x,y) (pos can be 'left' or 'right').
 Use the given 'pattern' for display, where {PAGENUM} and {TOTALPAGENUM} are replaced as required, by default the pattern is set to '{PAGENUM} of {TOTALPAGENUM}'
 If $num is set, then make the first page this number, the number of total pages will be adjusted to account for this.

 the following code produces a seven page document, numbered from the second page (which will be labelled '1 of 6'), and numbered until the 6th page (labelled '5 of 6')

#C
$pdf = new Cezpdf();
$pdf->selectFont('./fonts/Helvetica.afm');
$pdf->ezNewPage();
$pdf->ezStartPageNumbers(300,500,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->line(300,400,300,600); // line drawn to check 'pos' is working
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(); 
$pdf->ezStream();
#c

This function was modified in version 009 to return a page numbering set number (setNum in the call above), this allows independent numbering schemes to be started and stopped within a single document. This number is passed back into <i>ezStopPageNumbers</i> when it is called.

Here is a more complex example:

#C

$pdf->selectFont('./fonts/Helvetica');
$pdf->ezNewPage();
$i=$pdf->ezStartPageNumbers(300,500,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(1,1,$i);
$pdf->ezNewPage();
$i=$pdf->ezStartPageNumbers(300,500,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(1,1,$i);
$pdf->ezNewPage();
$i=$pdf->ezStartPageNumbers(300,500,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->setColor(1,0,0);
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(1,1,$i);
$pdf->ezNewPage();
$i=$pdf->ezStartPageNumbers(300,500,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezNewPage();
$j=$pdf->ezStartPageNumbers(300,400,20,'','',1);
$k=$pdf->ezStartPageNumbers(300,300,20,'','',1);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(1,1,$i);
$pdf->ezNewPage();
$pdf->ezNewPage();
$pdf->ezStopPageNumbers(1,1,$j);
$pdf->ezStopPageNumbers(0,1,$k);
$pdf->ezNewPage();
$pdf->ezNewPage();
#c

This will create a document with 23 pages, the numbering shown on each of the pages is:

#X
$array = array(
array('p'=>1,'c'=>'blank')
,array('p'=>2,'c'=>'1 of 3')
,array('p'=>3,'c'=>'2 of 3')
,array('p'=>4,'c'=>'3 of 3')
,array('p'=>5,'c'=>'1 of 3')
,array('p'=>6,'c'=>'2 of 3')
,array('p'=>7,'c'=>'3 of 3')
,array('p'=>8,'c'=>'1 of 3')
,array('p'=>9,'c'=>'2 of 3')
,array('p'=>10,'c'=>'3 of 3')
,array('p'=>11,'c'=>'4 of 4')
,array('p'=>12,'c'=>'1 of 8')
,array('p'=>13,'c'=>'2 of 8')
,array('p'=>14,'c'=>'3 of 8')
,array('p'=>15,'c'=>'4 of 8')
,array('p'=>16,'c'=>'5 of 8, 1 of 6, 1 of 8')
,array('p'=>17,'c'=>'6 of 8, 2 of 6, 2 of 8')
,array('p'=>18,'c'=>'7 of 8, 3 of 6, 3 of 8')
,array('p'=>19,'c'=>'8 of 8, 4 of 6, 4 of 8')
,array('p'=>20,'c'=>'5 of 6, 5 of 8')
,array('p'=>21,'c'=>'6 of 6, 6 of 8')
,array('p'=>22,'c'=>'blank')
,array('p'=>23,'c'=>'blank')
);
$pdf->ezTable($array,array('p'=>'page','c'=>'contents'));
#x


2<ezWhatPageNumber>

num = ezWhatPageNumber(pageNum,[setNum])

Returns the number of a page within the specified page numbering system.

'pageNum' => the absolute number of the page within the document (this is based on the order that they are created).
'setNum' => the page numbering set, returned from the <i>ezStartPageNumbers</i> command.


2<ezStopPageNumbers>

ezStopPageNumbers([stopTotal],[next],[setNum])

In version 009 this function was enhanced to include a number of extra parameters:

'stopTotal' => 0 or 1 (default 0), stops the totaling for the page numbering set. So for example if you start numbering a 10 page document on the second page, and stop it on the 4th page, with stopTotal set to 1, then the numbers will be reported as "x of 3".
'next' => 0 or 1, stops on the next page, not this one.
'setNum' => (defaults to 0) define which set number is to be stopped, this is the number returned from the <i>ezStartPageNumbers</i> command.
 
2<ezOutput>

ezOutput([debug])

Very similar to the output function from the base class, but performs any closing tasks that ezpdf requires, such as adding the page numbers.

If you are using ezpdf, then you should use this function, rather than the one from the base class.

2<ezStream>

ezStream([options])

Very similar to the stream function from the base class (all the same options, see later in this document), but performs any closing tasks that ezpdf requires, such as adding the page numbers.

If you are using ezpdf, then you should use this function, rather than the one from the base class.

2<ezColumnsStart>

ezColumnsStart([options])

This will start the text flowing into columns, <i>options</i> is an array which contains the control options.

The options are:
'gap' => the gap between the columns
'num' => the number of columns.

Both options (and the array itself) are optional, if missed out then the defaults are gap=10, num=2;

Example calls could be (you would use only one of these):

#C
$pdf->ezColumnsStart();
$pdf->ezColumnsStart(array('num'=>3));
$pdf->ezColumnsStart(array('num'=>3,'gap'=>2));
$pdf->ezColumnsStart(array('gap'=>20));
#c 

<i>ezColumnStop</i> is used to stop multi-column mode.

2<ezColumnsStop>

ezColumnsStop()

This stops multi-column mode, it will leave the writing point at whatever level it was at, it is recommended that an ezNewPage() command is executed straight after this command, but for flexibility this is left up to the individual consumer.

2<inline codes>

There are a few callback functions (see the base class functions for an explanation of callback functions) which are contained within the ezPdf class, these are intended to make life easier. They enable complex operations to be done by including codes within the text stream.


<b>Underline</b>

Though underlining is supported in the ezPdf class by using the &lt;u> directive, if you choose to use the base class functions to add text (such as addtext) then this will not work, instead you can use the <i>uline</i> callback function.

(Note that what the ezPdf class does internally is convert the &lt;u> and &lt;/u> directives into callback function calls)

So as an example, this code adds some text with two pieces of underlining, one done each way

#C
$pdf->ezText('The &lt;u>quick brown&lt;/u> fox, is &lt;c:uline>sick of jumping&lt;/c:uline> the lazy dog')
#c

The <u>quick brown</u> fox, is <c:uline>sick of jumping</c:uline> the lazy dog


<b>Links to URLs</b>

If you are adding links to a document, it is quite tricky to figure out where to put the rectange which will be clckable, especially if the text in teh link starts wrapping across pages, etc. 

The <i>alink</i> callback allows for simple insertion of links, the format is:

&lt;c:alink:<i>your_url_here</i>>text to be clickable&lt;/c:alink>


So as an example:

#C
$pdf->ezText('&lt;c:alink:http://ros.co.nz/pdf/>R&OS pdf class&lt;/c:alink>');
#c

<c:alink:http://ros.co.nz/pdf/>R&OS pdf class</c:alink>

<b>Links within the document</b>

There is a directive similar to <i>alink</i>, but designed for linking within the document, this is the <i>ilink</i> callback function.

It is similar to <i>alink</i> except that instead of providing a URL the label of a pre-created destination should be used. 

&lt;c:ilink:<i>destination_label</i>>text to be clickable&lt;/c:ilink>

#C
// place required to be marked
$pdf->addDestination('xxxyyyzzz','Fit');
// add lots of stuff, new pages etc, then...
$pdf->ezText('&lt;c:ilink:xxxyyyzzz>R&OS pdf class&lt;/c:ilink>');
#c

Click here to go to the <c:ilink:toc5>5th item</c:ilink> on the table of contents.

Note that the code for the example and the actual one shown are not identical for technical reasons.

#NP
1<Base Class Functions>


2<addText>

addText(x,y,size,text,[angle=0],[adjust=0])

Add the text at a particular location on the page, noting that the origin on the axes in a pdf document is in the lower left corner by default.
An angle can be supplied as this will do the obvious (in degrees).

'adjust', gives the value of units to be added to the width of each space within the text. This is used mainly to support the justification options within the ezpdf ezText function.

The text stream can now (version 006) contain directives to make the text bold and/or italic. The directives are similar the basic html: 

&lt;b&gt;<b>bold text</b>&lt;/b&gt; 
&lt;i&gt;<i>italic text</i>&lt;/i&gt; 
&lt;b&gt;&lt;i&gt;<b><i>bold italic text</i></b>&lt;i&gt;&lt;/b&gt; 

<b>Note</b> that there can be no spaces within the directives, and that they must be in lower case.

By default, these will work only with the supplied fonts, and when the font was selected it must have been specified with the '.afm' suffix. For more information about why this is and how you can customise this behaviour see the <b>setFontFamily</b> command.

If you do wish to print an actual '<', most of the time it would cause no problem, except in the instance where it would form a directive, in those cases the html replacement for the '<' can be used, "&amp;lt;". In fact if any of the html entities which are supported by the PHP htmlspecialchars command are used, then they will be translated before presentation.

#C
$pdf->addText(150,$y,10,"the quick brown fox &lt;b>jumps&lt;/b> &lt;i>over&lt;/i> the lazy dog!",-10);
#c
#X
$pdf->ezSetDy(-40,'makeSpace');
$pdf->addText(150,$pdf->y,10,"the quick brown fox <b>jumps</b> <i>over</i> the lazy dog!",-10);
$pdf->ezSetDy(-5);
#x

2<setColor>

setColor(r,g,b,[force=0])

Set the fill colour to the r,g,b triplet, each in the range 0->1.
If force is set, then the entry will be forced into the pdf file, otherwise it will only be put in if it is different from the current state.

2<setStrokeColor>

setStrokeColor(r,g,b,[force=0])

Set the stroke color, see the notes for the fill color.

2<setLineStyle>

setLineStyle([width],[cap],[join],[dash],[phase])

This sets the line drawing style.
 width, is the thickness of the line in user units
 cap is the type of cap to put on the line, values can be 'butt','round','square' where the difference between 'square' and 'butt' is that 'square' projects a flat end past the end of the line.
 join can be 'miter', 'round', 'bevel'
 dash is an array which sets the dash pattern, is a series of length values, which are the lengths of the on and off dashes.
   for example: (2) represents 2 on, 2 off, 2 on , 2 off ...
      (2,1) is 2 on, 1 off, 2 on, 1 off.. etc
 phase is a modifier on the dash pattern which is used to shift the point at which the pattern starts. 

#C
$pdf->setLineStyle(1);
#c
#X
$pdf->setLineStyle(1);
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5);
#c
#X
$pdf->setLineStyle(5);
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5,'round');
#c
#X
$pdf->setLineStyle(5,'round');
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5,'','',array(5));
#c
#X
$pdf->setLineStyle(5,'','',array(5));
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5,'','',array(10,5));
#c
#X
$pdf->setLineStyle(5,'','',array(10,5));
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5,'','',array(20,5,10,5));
#c
#X
$pdf->setLineStyle(5,'','',array(20,5,10,5));
$pdf->ezSetDy(-8,'makeSpace',4);
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x
#C
$pdf->setLineStyle(5,'round','',array(0,15));
#c
#X
$pdf->setLineStyle(5,'round','',array(0,15));
$pdf->ezSetDy(-8,'makeSpace');
$pdf->line(100,$pdf->y,400,$pdf->y);
$pdf->ezSetDy(-5);
#x

Note that the code shown with each of these lines is just the line style command, the drawing of each line also requires a <b>line</b> command, which is not shown.

2<line>

line(x1,y1,x2,y2)

Draw a line from (x1,y1) to (x2,y2), set the line width using setLineStyle.

2<curve>

curve(x0,y0,x1,y1,x2,y2,x3,y3)

Draw a Bezier curve. The end points are (x0,y0)->(x3,y3), and the control points are the other two.

Bezier curves are neat, but probably not for the novice. The <b>ellipse</b> command uses a series of Bezier curves to make the ellipse.

The distinctive feature of these curves is that the curve is guaranteed to lie within the 4 sided polygon formed from the 4 control points (they are also computationally easy to draw). An example is shown below with the control points marked.

#C
$pdf->curve(200,$y+40,250,$y+5,350,$y,400,$y+45);
#c
#X
$pdf->ezSetDy(-50,'makeSpace');
$y = $pdf->y;
$pdf->setLineStyle(2);
$pdf->curve(200,$y+40,250,$y+5,350,$y,400,$y+45);
$pdf->setLineStyle(0.5);
$pdf->ellipse(200,$y+40,5);
$pdf->ellipse(250,$y+5,5);
$pdf->ellipse(350,$y,5);
$pdf->ellipse(400,$y+45,5);
$pdf->setLineStyle(0.5,'','',array(10,5));
$pdf->line(200,$y+40,250,$y+5);
$pdf->line(250,$y+5,350,$y);
$pdf->line(350,$y,400,$y+45);
#x

Note that the Bezier curve is a tangent to the line between the control points at either end of the curve.

2<ellipse>

ellipse(x0,y0,r1,[r2=0],[angle=0],[nSeg=8])

Draw an ellipse, centred ay (x0,y0), with radii (r1,r2), oriented at 'angle' (anti-clockwise), and formed from nSeg bezier curves (the default 8 gives a reasonable approximation to the required shape).

If r2 is left out, or set to zero, then it is assumed that a circle is being drawn.

#C
$pdf->ellipse(300,$y+25,20);
#c
#X
$pdf->ezSetDy(-50,'makeSpace');
$pdf->setLineStyle(2);
$pdf->ellipse(300,$pdf->y+25,20);
#x

#C
$pdf->ellipse(300,$y+25,40,20);
#c
#X
$pdf->ezSetDy(-50,'makeSpace');
$pdf->setLineStyle(2);
$pdf->ellipse(300,$pdf->y+25,40,20);
#x

#C
$pdf->ellipse(300,$y+25,40,20,45);
#c
#X
$pdf->ezSetDy(-50,'makeSpace');
$pdf->setLineStyle(2);
$pdf->ellipse(300,$pdf->y+25,40,20,45);
#x

Of course the previous line style features also apply to these lines

#C
$pdf->setLineStyle(4,'round','',array(0,6,4,6));
$pdf->ellipse(300,$y+25,40,20,45);
#c
#X
$pdf->ezSetDy(-50,'makeSpace');
$pdf->setLineStyle(4,'round','',array(0,6,4,6));
$pdf->ellipse(300,$pdf->y+25,40,20,45);
#x

2<partEllipse>

partEllipse(x,y,a1,a2,r1 [,r2] [,angle] [,nSeg])

Draw a part ellipse (or circle), draw an ellipse centered on (x,y) from angle 'a1' to angle 'a2' (in degrees), with radius 'r1' in the x-direction and 'r2' in the y-direction and oriented at angle 'angle'. If 'r2' is not supplied the it defaults to 'r1' and a circle is formed.

#C
$pdf->ellipse(300,$y+25,38);
$pdf->partEllipse(300,$y+25,119,421,80,12,10);
$pdf->partEllipse(300,$y+25,117,423,84,14,10);
$pdf->partEllipse(300,$y+25,115,425,85,15,10);
#c

#X
$pdf->ezSetDy(-60,'makeSpace');
$pdf->ellipse(300,$pdf->y+25,38);
$pdf->partEllipse(300,$pdf->y+25,119,421,80,12,10);
$pdf->partEllipse(300,$pdf->y+25,117,423,84,14,10);
$pdf->partEllipse(300,$pdf->y+25,115,425,85,15,10);
#x

2<polygon>

polygon(p,np,[f=0])

Draw a polygon, where there are np points, and p is an array containing (x0,y0,x1,y1,x2,y2,...,x(np-1),y(np-1)).
If f=1 then fill the area.

#C
$pdata = array(200,10,400,20,300,50,150,40);
$pdf->polygon($pdata,4);
#c
#X
$pdata = array(200,10,400,20,300,50,150,40);
$pdf->ezSetDy(-60,'makeSpace');
for ($i=1;$i<count($pdata);$i+=2){
  $pdata[$i]+=$pdf->y;
}
$pdf->polygon($pdata,4);
#x

#C
$pdf->polygon($pdata,4,1);
#c
#X
$pdf->ezSetDy(-60,'makeSpace');
$pdata = array(200,10,400,20,300,50,150,40);
$pdf->ezSetDy(-60,'makeSpace');
for ($i=1;$i<count($pdata);$i+=2){
  $pdata[$i]+=$pdf->y;
}
$pdf->polygon($pdata,4,1);
#x

#C
$pdf->setColor(0.9,0.9,0.9);
$pdf->polygon($pdata,4,1);
#c
#X
$pdf->ezSetDy(-60,'makeSpace');
$pdata = array(200,10,400,20,300,50,150,40);
$pdf->ezSetDy(-60,'makeSpace');
for ($i=1;$i<count($pdata);$i+=2){
  $pdata[$i]+=$pdf->y;
}
$pdf->setColor(0.9,0.9,0.9);
$pdf->polygon($pdata,4,1);
#x


2<filledRectangle>

filledRectangle(x1,y1,width,height)

Obvious.

2<rectangle>

rectangle(x1,y1,width,height)

Obvious.

2<newPage>

id=newPage([insert,id,pos])

Starts a new page and returns the id of the page contents, this can be safely ignored, but storing it will allow the insertion of more information back into the page later, through the use of the 'reopenObject' function.

The command is usually used without any of the options to simply add a new page to the end of the current bunch, but with the options can be used to insert a page within the existing pages. The 'insert' value can be set to 0 or 1 (use 1 to insert). 'id' should be set to a value which was returned by a previous newPage command (this is actually the object id of the contents of a page). 'pos' will determine whether the page is inserted before or after the specified page, it should be set to 'before' or 'after'.

2<getFirstPageId>

id=getFirstPageId()

A related command is this which returns the id of the first page, this page is created during the class instantiation and so does not have its id returned to the user, this is the only way to fetch it, but it can be done at any point.

2<stream>

stream([array options])

Used for output, this will set the required headers and output the pdf code.

The options array can be used to set a number of things about the output:

 'Content-Disposition'=>'filename' sets the filename, though not too sure how well this will work as in my trial the browser seems to use the filename of the php file with .pdf on the end.
 'Accept-Ranges'=>1 or 0 - if this is not set to 1, then this header is not included, off by default this header seems to have caused some problems despite the fact that it is supposed to solve them, so I am leaving it off by default.
 'compress'=> 1 or 0 - apply content stream compression, this is on (1) by default.

2<getFontHeight>

x=getFontHeight(size)

Returns the height of the current font, in the given size. This is the distance from the bottom of the descender to the top of the Capitals.

2<getFontDecender>

x=getFontDecender(size)

Returns a number which is the distance that the descender goes beneath the Baseline, for a normal character set this is a negative number. 

2<getTextWidth>

x=getTextWidth(size,text)

Returns the width of the given text string at the given size.

2<addTextWrap>

a=addTextWrap(x,y,width,size,text,[justification='left'][,angle=0])

Will print the text string to the page at the position (x,y), if the string is longer than width, then it will print only the part which will fit within that width (attempting to truncate at a space if possible) and will return the remainder of the string. 

'justification' is optional and can be set to 'left','right','center','centre','full'. It provides for the justification of the text and though quite usable here, was implemented for the ezpdf class.

2<saveState>

saveState()

Save the graphic state.

2<restoreState>

restoreState()

Restore a saved graphics state.

2<openObject>

id=openObject()

Start an independent object. This will return an object handle, and all further writes to a page will actually go into this object, until a closeObject call is made.

2<reopenObject>

reopenObject(id)

Makes the point of current content insertion the numbered object, this 'id' must have been returned from a call to 'openObject' or 'newPage' for it to be a valid object to insert content into. Do not forget to call 'closeObject' to close off input to this object a